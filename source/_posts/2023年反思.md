---
title: 我的2023年反思
tags: 后端
category: 反思与总结
---

# 2023年反思

工作半年有余，临近春节，候车室内闲来无事，随笔记录一些反思。

## 一 时间

在滴滴工作的这半年多里，感触最大的就是时间不够用，而反观其他同学往往游刃有余。

我总结了以下几点，需要在未来提升。

### 1 技术方案

入职以来，技术方案经常会在进行排期会之前没有完整产出并和mentor进行review，造成后续流程被频繁变动的技术方案打乱。

我总结以下几点原因。

- 经常出现需求还没有仔细分析清楚就进入到了prd评审中。这会导致在评审会上浪费大量时间在理解新名词上。没有足够的时间思考好一个改动点，产品同学就讲到了第二个改动点了。

- 技术方案在进入排期会前没有找大家进行review，导致排期和最后的技术方案的耗时match不上。

- 对技术现状认知不够充分。这会导致技术方案实际上和执行起来有diff。写技术方案的时候没有关注代码，只关注链路和基本的思路。

- 技术方案的图太丑，自己可能都没有心情再看一遍，我总结为，我缺乏画好图的能力。

解决方案：

- 管理好时间，在prd评审前需要有一份自己的理解，并落实到文档上。

- 技术方案需要在排期会前两天落地，并review两次以上，一次私人review，一次团队review。

- 在写技术方案的同时，关注代码细节，了解落实一段代码的成本到底是多少，影响面多大。

- 画好图，讲好话，这种能力需要长期积累。目前我努力的方向是模仿公司内的优秀文档，一张张图，一行行字抄一份出来。

### 2 代码实现

实际上，在落地代码的时候，也有很多时间被白白浪费掉。

#### 2.1 Dont repeat yourself

我没有做好。

线上也曾经出现过一些问题，就是因为repeat myself导致的。在我做的第一个大需求中，总是出一些窸窸窣窣的小问题，总结一下，竟然都是同样的代码写了两遍，修改了一处，忘了修改另一处。

导致这个问题的原因，我想和上述的时间紧张问题脱不开关系，可以算是一种连锁反应。当我写完一段代码的时候，再面对同样的逻辑，我内心甚至非常抵抗把这段逻辑落到common包中，每次抵抗的原因也都一样：代码写的一大段，一整坨，完全没有做好把它归纳到一个方func中，导致如果想落到common中，需要整理input,output，很抵触整理的过程。

### 3 时间管理

最近看了耗子叔的《左耳听风》，对其中的一章节深感赞同。我们在写代码的时候，总是被一些小事打扰，不是排查问题，就是开会。

我参考了文章中的内容，并且根据实际情况，总结出了以下方法，目前正在初步实施，希望能让类似情况有所好转。

1. 在个人闲忙日历上标注好当天什么时候在coding，什么时候在写方案，避免被打扰。同时对于非线上的紧急问题，顺排插入到每天的闲忙日历中。

2. 对于每一项大任务，留出一天的buffer，因为我们无法得知到底什么事情会影响我们的时间计划。这里的大任务，指的是需求的每个阶段：技术方案，开发，联调。

## 二 工程质量

这一节想到哪就写到哪了，有太多东西需要提升。其实这一节本来我想叫做代码质量，写完后发现很多东西和代码无关。

每一个问题我会拆成两个段落，第一段是现象，第二段是改进方案

### 1 安全

我对安全非常非常排斥，尤其是他们的介入导致我的工作量陡增。但是最近看了很多技术博客，以及看了一些公司内的事故复盘，认识到了安全问题真的很重要。这里的安全，我指的不仅仅是代码链路中增加封控策略，也有SQL注入等自己写代码的时候需要注意的事情。

幸好在最近的一个需求上线前，我看到了很多触目惊心的安全事故，因此在上线前重新review了一下可能存在的安全漏洞，并且把之前遗留了很久很久的安全工单解决了。我想在以后的需求中，我会第一个考虑功能的安全性。

### 2 存储选型

存储选型真的是一个令人头疼的问题。

- 持久化存储，还是缓存？

- 新开辟一个key，还是在原有的key对应的value上迭代？

- 存储的可用性保证？

针对上面三个我目前面对的头疼过的问题，给出我的总结，作为未来我再次遇到存储选型的时候的一个可参考项。

- 持久化还是缓存，要考虑以下事情。
  
  第一，业务对于存储丢失的容忍度。
  
  第二，团队体量对于存储选型是否可维护。

- 新的key，还是老的key？
  
  对于这个问题，我把它归结于是一个业务理解的问题。这里不多发表我浅薄的认知，我希望未来可以通过更多的公司内部分享，得到更多输入。目前解决这个问题的方法还是组内review技术方案。

- 存储的可用性？
  
  第一，这个存储是否会有并发问题。事实上我真的在编码过程中遇到过存储一致性问题，导致了一些边界case发生，幸好这些case并不影响用户体验。
  
  第二，存储数据的丢失，是否有兜底方案。
  
  目前我的手段是两个方向。首先，选择可用性更高的同类型存储，来存储业务对丢失容忍度低的数据。其次，通过业务的特性进行兜底报警，落盘(通过读取业务日志来存储日志内容)，这样可以在用户进线的时候给出补偿方案。
  
  > 稍微提一嘴我的小奇技淫巧，使用二进制位来标识用户是否做出了某项决策，该决策只有0/1，且置为1后无法被回退到0。同业务类型的“决策”共有两种，我使用了两个二进制位来表示，因此枚举值共有 0 1 2 3四种。而最开始的方法是使用加法运算(这是因为我实在不想在代码里写位运算，我自己看见位运算都恶心，我不想恶心别人，而恰好用加法运算和或运算结果一样...)，在上线后统计数据，发现枚举值有极小部分被累加到了十几，紧急更换为位运算，perfect!解决了并发问题。

### 3 代码维护性

代码CR的时候被人喷过一次代码维护性差。我个人认为我的注释写的还是不错的，因为我确实喜欢在项目里几乎每一个我写的代码块都标注上why。

在CR的时候被人喷了一嘴，虽然注释写了，但是代码散落在各地，维护起来很困难。

所谓“代码散落在各地”，实际上是代码的逻辑散落在各地。如果想迭代我写过的代码，很容易造成改了一处，另一处因为放在了别的地方，没有被修改。



解决这个问题的方法：

1. 逻辑落在function或者common包中

2. 相关逻辑要写在同一个地方。比如数据的处理最好放在获取数据源的代码附近，而不是在经过一大串的其他逻辑后，最后才处理这份数据源。



> 这里说一下代码注释的要点，一位滴滴的前辈曾经在文档中写过，代码注释要写好why，而不是how。我深表赞同。

### 4 任何东西都不可靠！

所谓任何东西都不可靠，指的是中间件，微服务，多线程等任何不可知结果的东西。

任何中间件都不能假设它成功，必须考虑边界条件，比如延时mq没有按期到达，比如redis等存储丢失。

任何微服务都不能假设它按照预期返回data，甚至下游给出的errno枚举也不可靠，我们必须做异常处理。对于重要的业务，甚至还要做代码mockrpc返回的兜底处理。

多线程这个目前我的感知还真的不深刻，因为我的代码很少涉及到多线程。希望在未来可以涉及到相关的开发，这里不抛出我的浅薄见解。



总而言之，在技术方案产出的时候，就要考虑到各种各样的错误。当然我们不能完全看全所有的异常，因此，错误日志，监控，报警等一定不能偷懒，多加一个监控报警，就是对自己的保护，防止线上出现很久问题了，等到进线来了才感知到异常情况的发生。

## 总结

以上就是我的2023回顾，期待新的一年能有更多的成长。

> Stay hungry. Stay foolish.


